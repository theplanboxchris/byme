<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keyword Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: #4f46e5;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 24px;
            margin-bottom: 5px;
        }
        
        .header p {
            opacity: 0.8;
            font-size: 14px;
        }
        
        .content {
            padding: 20px;
        }
        
        .section {
            margin-bottom: 30px;
        }
        
        .section h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #374151;
        }
        
        .add-keyword {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .add-keyword input, .add-keyword select {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 16px;
        }
        
        .add-keyword button {
            padding: 12px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .add-keyword button:hover {
            background: #059669;
        }
        
        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .filters input, .filters select {
            flex: 1;
            min-width: 120px;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
        }
        
        .keyword-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
        }
        
        .keyword-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .keyword-item:last-child {
            border-bottom: none;
        }
        
        .keyword-item input[type="checkbox"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
        }
        
        .keyword-info {
            flex: 1;
        }
        
        .keyword-word {
            font-weight: 500;
            color: #374151;
        }
        
        .keyword-category {
            font-size: 12px;
            color: #6b7280;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 12px;
            display: inline-block;
            margin-top: 4px;
        }
        
        .selected-count {
            background: #dbeafe;
            color: #1e40af;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 500;
        }
        
        .download-section {
            text-align: center;
        }
        
        .download-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            font-weight: 500;
            width: 100%;
            margin-bottom: 15px;
        }
        
        .download-btn:hover {
            background: #b91c1c;
        }
        
        .download-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .instructions {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 6px;
            padding: 15px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .instructions h3 {
            color: #92400e;
            margin-bottom: 10px;
        }
        
        .instructions ol {
            margin-left: 20px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            color: #6b7280;
        }
        
        .error {
            background: #fef2f2;
            border: 1px solid #f87171;
            color: #dc2626;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 15px;
        }
        
        @media (max-width: 480px) {
            .add-keyword {
                flex-direction: column;
            }
            
            .filters {
                flex-direction: column;
            }
            
            .add-keyword input, .add-keyword select, .add-keyword button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîó Keyword Manager</h1>
            <p>Select keywords for your BLE proximity device</p>
        </div>
        
        <div class="content">
            <!-- Add Keyword Section -->
            <div class="section">
                <h2>‚ûï Add New Keyword</h2>
                <div class="add-keyword">
                    <input type="text" id="newKeyword" placeholder="Enter keyword..." maxlength="50">
                    <select id="newCategory">
                        <option value="general">General</option>
                        <option value="maritime">Maritime</option>
                        <option value="weather">Weather</option>
                        <option value="emergency">Emergency</option>
                        <option value="activities">Activities</option>
                        <option value="technology">Technology</option>
                    </select>
                    <button onclick="addKeyword()">Add</button>
                </div>
                <div id="addError" class="error" style="display: none;"></div>
            </div>
            
            <!-- Filter Section -->
            <div class="section">
                <h2>üîç Browse Keywords</h2>
                <div class="filters">
                    <input type="text" id="searchKeyword" placeholder="Search keywords..." onkeyup="filterKeywords()">
                    <select id="filterCategory" onchange="filterKeywords()">
                        <option value="">All Categories</option>
                    </select>
                </div>
                
                <div id="keywordList" class="loading">Loading keywords...</div>
            </div>
            
            <!-- Device Connection Section -->
            <div class="section">
                <h2>ÔøΩ Device Connection</h2>
                <div id="connectionStatus" class="selected-count">No device connected</div>
                
                <div class="download-section">
                    <button class="download-btn" onclick="sendKeywordsOnce()">
                        üì§ Send Keywords to ESP32
                    </button>

                    <div id="sendKeywordsMessage" style="display: none; margin-top: 10px; padding: 12px; border-radius: 6px; font-weight: 500; text-align: center;"></div>

                    <div id="transferStatus" class="instructions" style="display: none;">
                        <h3>üìä Transfer Status:</h3>
                        <div id="transferMessage">Ready to transfer...</div>
                        
                        <!-- Debug Console -->
                        <details style="margin-top: 15px;">
                            <summary style="cursor: pointer; font-weight: bold; color: #6b7280;">üîß Debug Console</summary>
                            <div id="debugConsole" style="background: #1f2937; color: #f3f4f6; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 11px; max-height: 150px; overflow-y: auto; margin-top: 10px; white-space: pre-wrap;">Debug information will appear here...</div>
                        </details>
                    </div>
                    
                    <div class="instructions">
                        <h3>üìã How to Use:</h3>
                        <ol>
                            <li>Select keywords from the list above</li>
                            <li>Click "Find Nearby Device" to discover your ESP32-C3</li>
                            <li>Once connected, click "Transfer Keywords to Device"</li>
                            <li>Device will automatically start scanning with new keywords</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    const API_BASE = 'http://localhost:9080';
        let allKeywords = [];
        let selectedKeywords = new Set();
        let connectedDevice = null;
        let deviceCharacteristic = null;

        // Load initial data
        async function init() {
            try {
                await Promise.all([loadKeywords(), loadCategories()]);
            } catch (error) {
                console.error('Failed to initialize:', error);
                document.getElementById('keywordList').innerHTML = 
                    '<div class="error">Failed to load keywords. Is the API server running?</div>';
            }
        }

        // Load all keywords
        async function loadKeywords() {
            try {
                const response = await fetch(`${API_BASE}/keywords`);
                if (!response.ok) throw new Error('Failed to fetch keywords');
                
                allKeywords = await response.json();
                renderKeywords(allKeywords);
            } catch (error) {
                throw error;
            }
        }

        // Load categories for filter dropdown
        async function loadCategories() {
            try {
                const response = await fetch(`${API_BASE}/categories`);
                if (!response.ok) throw new Error('Failed to fetch categories');
                
                const data = await response.json();
                const select = document.getElementById('filterCategory');
                
                data.categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category.charAt(0).toUpperCase() + category.slice(1);
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load categories:', error);
            }
        }

        // Render keywords list
        function renderKeywords(keywords) {
            const listDiv = document.getElementById('keywordList');
            
            if (keywords.length === 0) {
                listDiv.innerHTML = '<div class="loading">No keywords found. Add some keywords first!</div>';
                return;
            }

            const html = keywords.map(keyword => `
                <div class="keyword-item">
                    <input type="checkbox" id="kw-${keyword.id}" 
                           onchange="toggleKeyword(${keyword.id}, '${keyword.word}')">
                    <div class="keyword-info">
                        <div class="keyword-word">${keyword.word}</div>
                        <span class="keyword-category">${keyword.category}</span>
                    </div>
                </div>
            `).join('');

            listDiv.innerHTML = `<div class="keyword-list">${html}</div>`;
        }

        // Filter keywords
        function filterKeywords() {
            const search = document.getElementById('searchKeyword').value.toLowerCase();
            const category = document.getElementById('filterCategory').value;

            const filtered = allKeywords.filter(keyword => {
                const matchesSearch = keyword.word.toLowerCase().includes(search);
                const matchesCategory = !category || keyword.category === category;
                return matchesSearch && matchesCategory;
            });

            renderKeywords(filtered);
        }

        // Toggle keyword selection
        function toggleKeyword(id, word) {
            const checkbox = document.getElementById(`kw-${id}`);
            
            if (checkbox.checked) {
                selectedKeywords.add(word);
            } else {
                selectedKeywords.delete(word);
            }

            updateSelectedCount();
        }

    // Update selected count display
    function updateSelectedCount() {
        const count = selectedKeywords.size;
        const transferBtn = document.querySelector('.download-btn');

        transferBtn.disabled = count === 0;
        
        updateSelectedCountDisplay();
    }

    // Update the selected count display (without connection info)
    function updateSelectedCountDisplay() {
        const statusDiv = document.getElementById('connectionStatus');
        const count = selectedKeywords.size;

        statusDiv.textContent = `${count} keyword${count === 1 ? '' : 's'} selected`;
        statusDiv.style.background = '#dbeafe'; // light blue background
        statusDiv.style.color = '#1e40af';      // dark blue text
    }

        // Update connection status display
        function updateConnectionStatus() {
            const statusDiv = document.getElementById('connectionStatus');
            const count = selectedKeywords.size;
            
            if (connectedDevice) {
                statusDiv.textContent = `${count} keyword${count === 1 ? '' : 's'} selected`;
                statusDiv.style.background = '#dcfce7';
                statusDiv.style.color = '#166534';
            } else {
                statusDiv.textContent = `${count} keyword${count === 1 ? '' : 's'} selected`;
                statusDiv.style.background = '#fef2f2';
                statusDiv.style.color = '#dc2626';
            }
        }

        // Add new keyword
        async function addKeyword() {
            const wordInput = document.getElementById('newKeyword');
            const categorySelect = document.getElementById('newCategory');
            const errorDiv = document.getElementById('addError');

            const word = wordInput.value.trim();
            const category = categorySelect.value;

            if (!word) {
                showError('Please enter a keyword');
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/keywords`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word, category })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to add keyword');
                }

                // Success - reload keywords and clear form
                wordInput.value = '';
                categorySelect.value = 'general';
                errorDiv.style.display = 'none';
                
                await loadKeywords();
                await loadCategories(); // Refresh categories in case new one was added

            } catch (error) {
                showError(error.message);
            }
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('addError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => errorDiv.style.display = 'none', 5000);
        }

        // Debug logging function
        function debugLog(message) {
            const debugConsole = document.getElementById('debugConsole');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            
            console.log(message); // Also log to browser console
            
            if (debugConsole) {
                debugConsole.textContent += logEntry;
                debugConsole.scrollTop = debugConsole.scrollHeight; // Auto-scroll to bottom
            }
        }


async function sendKeywordsOnce() {
    const messageDiv = document.getElementById('sendKeywordsMessage');

    if (selectedKeywords.size === 0) {
        showKeywordMessage('‚ùå No keywords selected!', 'error');
        return;
    }

    try {
        showKeywordMessage('üîç Searching for device...', 'info');
        console.log('[Frontend] Requesting BLE device: ESP32-BLE-FILE');

        // Request and connect to device
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ name: 'ESP32-BLE-FILE' }],
            optionalServices: ['12345678-1234-5678-1234-56789abcdef0']
        });

        showKeywordMessage('üîó Connecting to device...', 'info');
        const server = await device.gatt.connect();
        console.log('[Frontend] Connected to GATT server');

        const service = await server.getPrimaryService('12345678-1234-5678-1234-56789abcdef0');
        console.log('[Frontend] Found service: 12345678-1234-5678-1234-56789abcdef0');

        const characteristic = await service.getCharacteristic('12345678-1234-5678-1234-56789abcdef1');
        console.log('[Frontend] Found characteristic: 12345678-1234-5678-1234-56789abcdef1');

        // Prepare JSON + EOF
        const keywordsArray = Array.from(selectedKeywords);
        const jsonPart = JSON.stringify({ keywords: keywordsArray });
        const eofMarker = "<EOF>";
        const jsonString = jsonPart + eofMarker;
        const encoder = new TextEncoder();
        const fullPayload = encoder.encode(jsonString);

        console.log(`[Frontend] Keywords: ${JSON.stringify(keywordsArray)}`);
        console.log(`[Frontend] JSON part: "${jsonPart}" (${jsonPart.length} bytes)`);
        console.log(`[Frontend] EOF marker: "${eofMarker}" (${eofMarker.length} bytes)`);
        console.log(`[Frontend] Complete string: "${jsonString}"`);
        console.log(`[Frontend] Total payload: ${fullPayload.length} bytes`);
        console.log(`[Frontend] Payload as array: [${Array.from(fullPayload).join(', ')}]`);

        showKeywordMessage(`üì§ Sending ${keywordsArray.length} keyword(s)...`, 'info');

        // Try to send the entire payload in one write first
        try {
            console.log(`[Frontend] Attempting to send entire payload in one write...`);
            console.log(`[Frontend] Payload size: ${fullPayload.length} bytes`);

            // Try writeValueWithoutResponse first (for characteristics with FLAG_WRITE_NO_RESPONSE)
            if (characteristic.writeValueWithoutResponse) {
                console.log(`[Frontend] ‚úÖ Using writeValueWithoutResponse`);
                await characteristic.writeValueWithoutResponse(fullPayload);
            } else {
                console.log(`[Frontend] ‚ö†Ô∏è  writeValueWithoutResponse not available, using writeValue`);
                await characteristic.writeValue(fullPayload);
            }

            console.log(`[Frontend] ‚úÖ Full payload sent in one write!`);
            showKeywordMessage(`üì§ Payload sent. Waiting for device to save...`, 'info');

        } catch (singleWriteError) {
            console.warn(`[Frontend] Single write failed: ${singleWriteError.message}`);
            console.log(`[Frontend] Falling back to chunked transfer (20 byte chunks)...`);

            // Fallback: send in small 20-byte chunks for ESP32 BLE MTU compatibility
            const chunkSize = 20;
            const totalChunks = Math.ceil(jsonString.length / chunkSize);
            let chunksSent = 0;

            showKeywordMessage(`üì§ Sending ${keywordsArray.length} keyword(s) in ${totalChunks} chunks...`, 'info');

            for (let i = 0; i < jsonString.length; i += chunkSize) {
                const chunkStr = jsonString.slice(i, i + chunkSize);
                const chunk = encoder.encode(chunkStr);
                chunksSent++;

                try {
                    console.log(`[Frontend] Chunk ${chunksSent}/${totalChunks}: "${chunkStr}" (${chunk.length} bytes)`);

                    if (characteristic.writeValueWithoutResponse) {
                        await characteristic.writeValueWithoutResponse(chunk);
                    } else {
                        await characteristic.writeValue(chunk);
                    }

                    console.log(`[Frontend] ‚úÖ Chunk ${chunksSent} sent`);
                    // Longer delay between chunks to ensure ESP32 can process each one
                    await new Promise(r => setTimeout(r, 300));

                } catch (chunkError) {
                    console.error(`[Frontend] ‚ùå Chunk ${chunksSent} failed: ${chunkError.message}`);
                    throw chunkError;
                }
            }

            console.log(`[Frontend] ‚úÖ All ${chunksSent} chunks sent`);
        }

        console.log(`[Frontend] Total bytes sent: ${fullPayload.length}`);
        showKeywordMessage(`üì§ Payload sent. Waiting for device to save file...`, 'info');

        // Wait longer before disconnecting to ensure device finishes processing
        // This gives the ESP32 time to handle all IRQ events and save the file
        console.log('[Frontend] Waiting 5 seconds for device to process and save...');
        await new Promise(r => setTimeout(r, 5000));

        console.log('[Frontend] Disconnecting from device');
        await server.disconnect();

        showKeywordMessage(`‚úÖ Keywords sent successfully! (${keywordsArray.length} keywords)`, 'success');
        console.log('[Frontend] Transfer complete!');

        // Auto-hide success message after 5 seconds
        setTimeout(() => {
            messageDiv.style.display = 'none';
        }, 5000);

    } catch (error) {
        console.error("BLE transfer failed:", error);
        console.error(`Error name: ${error.name}`);
        console.error(`Error message: ${error.message}`);
        showKeywordMessage(`‚ùå Transfer failed: ${error.message}`, 'error');
    }
}

// Helper function to show messages with styling
function showKeywordMessage(message, type) {
    const messageDiv = document.getElementById('sendKeywordsMessage');
    messageDiv.textContent = message;
    messageDiv.style.display = 'block';

    if (type === 'success') {
        messageDiv.style.background = '#dcfce7';
        messageDiv.style.color = '#166534';
        messageDiv.style.border = '1px solid #86efac';
    } else if (type === 'error') {
        messageDiv.style.background = '#fef2f2';
        messageDiv.style.color = '#dc2626';
        messageDiv.style.border = '1px solid #fca5a5';
    } else if (type === 'info') {
        messageDiv.style.background = '#dbeafe';
        messageDiv.style.color = '#1e40af';
        messageDiv.style.border = '1px solid #93c5fd';
    }
}




        // Monitor device output
        async function monitorDevice() {
            if (!connectedDevice) {
                return;
            }
            
            const monitorBtn = document.getElementById('monitorBtn');
            const messageDiv = document.getElementById('transferMessage');
            const statusDiv = document.getElementById('transferStatus');
            
            try {
                monitorBtn.textContent = 'üì∫ Getting Output...';
                monitorBtn.disabled = true;
                statusDiv.style.display = 'block';
                
                const response = await fetch('http://localhost:8000/esp32/serial');
                const result = await response.json();
                
                if (result.status === 'success' && result.output.length > 0) {
                    messageDiv.innerHTML = `
                        <strong>üì∫ ESP32-C3 Output:</strong><br>
                        <div style="background: #1f2937; color: #f3f4f6; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; white-space: pre-wrap;">${result.output.join('\n')}</div>
                    `;
                } else {
                    messageDiv.textContent = 'üì∫ No recent output from device. Device may be sleeping or restarting.';
                }
                
            } catch (error) {
                console.error('Monitor failed:', error);
                messageDiv.textContent = `‚ùå Monitor failed: ${error.message}`;
            } finally {
                monitorBtn.textContent = 'üì∫ Monitor Device Output';
                monitorBtn.disabled = false;
            }
        }

        // Download selected keywords (backup function)
        function downloadKeywords() {
            if (selectedKeywords.size === 0) return;

            const keywordsArray = Array.from(selectedKeywords);
            const data = { keywords: keywordsArray };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], 
                                { type: 'application/json' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'keywords.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Handle Enter key in new keyword input
        document.getElementById('newKeyword').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addKeyword();
            }
        });

        // Initialize app
        init();
        updateConnectionStatus(); // Set initial connection status
    </script>
</body>
</html>