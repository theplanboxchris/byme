



==========================================================
THE FULL CURRENT CODE

==========================================================

import bluetooth, time, ubinascii, ujson, machine, neopixel

# TO DO - Load this from keywords.json
# Simulate a list of keywords each with a unique index 
# MY_KEYWORDS =  {"jenga": 12534, "sailing": 33156, "dating": 22544}
MY_KEYWORDS = {}
try:
    with open('keywords.json', 'r') as f:
        MY_KEYWORDS = ujson.load(f)
except Exception as e:
    print('Could not load keywords.json:', e)
    MY_KEYWORDS = {}

# BLE constants
IRQ_SCAN_RESULT = 5
IRQ_SCAN_DONE = 6

# How long to ignore on the ignore list
IGNORE_DURATION = 2  # seconds
ignore_list = {}  # dict or list of tuples
# key: device address (string)
# value: timestamp when it can be removed

# HELPER FUNCTIONS
#----------------------------

def blink_neopixel(pin_num=2, color=(255, 0, 0), blink_time=0.1, duration=5):
    pin = machine.Pin(pin_num)
    np = neopixel.NeoPixel(pin, 1)
    end_time = time.time() + duration
    while time.time() < end_time:
        np[0] = color      # On
        np.write()
        time.sleep(blink_time)
        np[0] = (0, 0, 0)  # Off
        np.write()
        time.sleep(blink_time)


def device_name():
    mac = ubinascii.hexlify(ble.config('mac')[1]).decode().upper()
    dev_name = "NIMI_DEV_" + mac[-4:]
    return dev_name.encode()

def make_adv_payload(json_data, name):
    # Get up to 5 numbers from the values of the dict
    numbers = list(json_data.values())[:5]
    payload = bytearray()
    for number in numbers:
        payload += int(number).to_bytes(2, 'big')
    # Append the device name
    payload += name
    return payload

def decode_payload(payload):
    # Convert memoryview to bytes
    payload = bytes(payload)
    # Find the start of the device name (look for 'NIMI_DEV_')
    name_prefix = b'NIMI_'
    idx = payload.find(name_prefix)
    if idx == -1:
        # If not found, fallback to first printable ASCII
        i = 0
        while i < len(payload):
            if payload[i] >= 32 and payload[i] <= 126:
                break
            i += 1
        idx = i
    # Numbers are all bytes before idx, in 2-byte chunks
    numbers = []
    for j in range(0, idx, 2):
        if j+2 <= idx:
            n = int.from_bytes(payload[j:j+2], 'big')
            numbers.append(n)
    # Name is the rest
    name = payload[idx:]
    return name, numbers


def find_matches(json_dict, num_array):
    matches = []
    for key, value in json_dict.items():
        if value in num_array:
            matches.append(key)
    return matches


# Callback for scan results
def bt_irq(event, data):
    if event == IRQ_SCAN_RESULT:
        addr_type, addr, adv_type, rssi, adv_data = data
        name, keyword_idx = decode_payload(adv_data)
        #name = decode_name(adv_data)
        if name and "NIMI_" in name:
            # we found another 'NIMI' device
            print("→ Found:", name, "RSSI:", rssi)
            now = time.time()

            # Check if the device is already in the ignore list
            if name in ignore_list:
                if now < ignore_list[name]:
                    # Still within ignore duration
                    print("  - Ignoring (in ignore period)")
                    return
                else:
                    # Expired, will delete the old entry and process again
                    del ignore_list[name]
                    print("Processing old entry again")

            else:
                # New device
                print("Added and Processing")

            # Either new or expired — update the ignore timestamp
            ignore_list[name] = now + IGNORE_DURATION

            # Check for matches
            matches = find_matches(MY_KEYWORDS, keyword_idx)
            print('KEYWORD IDX: ', matches)
            if matches is not None:
                blink_neopixel(duration=5)

    elif event == IRQ_SCAN_DONE:
        print("Scan done")

# END HELPER FUNCTIONS
#----------------------------

# 1. Initialize BLE
ble = bluetooth.BLE()
ble.active(True)
# Register BLE IRQ handler
ble.irq(bt_irq)


# 2.  Create an advertising payload
name = device_name()
json_data = MY_KEYWORDS
adv_payload = make_adv_payload(json_data, name)


# 3.  Start advertising continuously
ble.gap_advertise(500_000, adv_data=adv_payload) 
print("[BLE] Advertising started with payload:", adv_payload)


# 4. Start scanning - callback bt_irq() triggered on events
ble.gap_scan(0, 50000, 50000)
print("[BLE] Scanning started..looking for devices:")

while True:
    # Periodic cleanup to remove devices that are now out of range (ignore_time is added when creaed, if that is less than now, delete)
    now = time.time()
    for name in list(ignore_list.keys()):
        if ignore_list[name] < now:
            del ignore_list[name]
    time.sleep(5)

==========================================================
THE FULL bt_irq()

==========================================================

# Callback for scan results
def bt_irq(event, data):
    if event == IRQ_SCAN_RESULT:
        addr_type, addr, adv_type, rssi, adv_data = data
        name, keyword_idx = decode_payload(adv_data)
        #name = decode_name(adv_data)
        if name and "NIMI_" in name:
            # we found another 'NIMI' device
            print("→ Found:", name, "RSSI:", rssi)
            now = time.time()

            # Check if the device is already in the ignore list
            if name in ignore_list:
                if now < ignore_list[name]:
                    # Still within ignore duration
                    print("  - Ignoring (in ignore period)")
                    return
                else:
                    # Expired, will delete the old entry and process again
                    del ignore_list[name]
                    print("Processing old entry again")

            else:
                # New device
                print("Added and Processing")

            # Either new or expired — update the ignore timestamp
            ignore_list[name] = now + IGNORE_DURATION

            # Check for matches
            #find_matches(MY_KEYWORDS, keyword_idx)
            print('KEYWORD IDX: ', keyword_idx)

    elif event == IRQ_SCAN_DONE:
        print("Scan done")



==========================================================
THE KEYWORD MATCHING ONLY STUFF

==========================================================


import bluetooth, ujson, ubinascii


MY_KEYWORDS =  {"jenga": 12534, "sailing": 33156, "dating": 22544}


# Unique name
def device_name():
    mac = ubinascii.hexlify(ble.config('mac')[1]).decode().upper()
    dev_name = "NIMI_DEV_" + mac[-4:]
    return dev_name.encode()

def make_adv_payload(json_data, name):
    # Get up to 5 numbers from the values of the dict
    numbers = list(json_data.values())[:5]
    payload = bytearray()
    for number in numbers:
        payload += int(number).to_bytes(2, 'big')
    # Append the device name
    payload += name
    return payload

def decode_payload(payload, dev_name):
    idx = payload.find(dev_name)
    if idx == -1:
        raise ValueError("Device name not found in payload")
    # All bytes before the device name are numbers (2 bytes each)
    numbers = []
    for i in range(0, idx, 2):
        n = int.from_bytes(payload[i:i+2], 'big')
        numbers.append(n)
    return numbers

def find_matches(json_dict, num_array):
    matches = []
    for key, value in json_dict.items():
        if value in num_array:
            matches.append(key)
    return matches



# 1. Initialize BLE
ble = bluetooth.BLE()
ble.active(True)


name = device_name()
json_str = '{"jenga": 12534, "poker": 23456, "chess": 34567}'
data = ujson.loads(json_str)
adv_payload = make_adv_payload(data,name)

keywords = decode_payload(adv_payload, name)

print('Created payload: ', adv_payload)

print('NAME: ', name, 'KEYWORDS:', keywords)

matches = find_matches(MY_KEYWORDS, keywords)

print('MATCHES: ', matches)


==========================================================

before the json stuff
============================================================

import bluetooth, time, ubinascii, ujson, machine

# BLE constants
IRQ_SCAN_RESULT = 5
IRQ_SCAN_DONE = 6

# How long to ignore on the ignore list
IGNORE_DURATION = 2  # seconds
ignore_list = {}  # dict or list of tuples
# key: device address (string)
# value: timestamp when it can be removed





# 1. Initialize BLE
ble = bluetooth.BLE()
ble.active(True)

# 2. Create advertising payload (e.g., your keyword ID)

# Unique name
mac = ubinascii.hexlify(ble.config('mac')[1]).decode().upper()
dev_name = "NIMI_DEV_" + mac[-4:]
print("[BLE] Advertising as:", dev_name)

_ADV_TYPE_NAME = 0x09

def make_payload(name):
    name_bytes = name.encode()
    payload = bytearray(b'\x02\x01\x06')
    payload.append(len(name_bytes) + 1)
    payload.append(_ADV_TYPE_NAME)
    payload.extend(name_bytes)
    return payload

def decode_payload(payload):
    adv_bytes = bytes(payload)
    name = None
    keywords = None
    i = 0
    while i < len(adv_bytes):
        length = adv_bytes[i]
        if length == 0:
            break
        ad_type = adv_bytes[i + 1]
        if ad_type == 0x01 and length == 2:
            # BLE flags
            keywords = adv_bytes[i:i+length+1]
        elif ad_type == 0x09:
            # Complete Local Name
            try:
                name = adv_bytes[i+2:i+length+1].decode('utf-8')
            except UnicodeError:
                name = None
        i += length + 1
    return name, keywords


def check_peer(keywords):
    print("→ DECODING NOW..:", keywords)

# Callback for scan results
def bt_irq(event, data):
    if event == IRQ_SCAN_RESULT:
        addr_type, addr, adv_type, rssi, adv_data = data
        name, keywords = decode_payload(adv_data)
        #name = decode_name(adv_data)
        if name and "NIMI_" in name:
            # we found another 'NIMI' device
            print("→ Found:", name, "RSSI:", rssi)
            now = time.time()

            # Check if the device is already in the ignore list
            if name in ignore_list:
                if now < ignore_list[name]:
                    # Still within ignore duration
                    print("  - Ignoring (in ignore period)")
                    return
                else:
                    # Expired, will delete the old entry and process again
                    del ignore_list[name]
                    print("Processing old entry again")

            else:
                # New device
                print("Added and Processing")

            # Either new or expired — update the ignore timestamp
            ignore_list[name] = now + IGNORE_DURATION

            check_peer(keywords)
            

    elif event == IRQ_SCAN_DONE:
        print("Scan done")

# Register BLE IRQ handler
ble.irq(bt_irq)



# 3. Start advertising

adv_payload = make_payload(dev_name)
ble.gap_advertise(500_000, adv_data=adv_payload)  # advertise continuously
print("[BLE] Advertising started with payload:", adv_payload)


# 4. Start scanning
ble.gap_scan(0, 50000, 50000)
print("[BLE] Scanning started..looking for devices:")

while True:
    # Periodic cleanup to remove devices that are now out of range (ignore_time is added when creaed, if that is less than now, delete)
    now = time.time()
    for name in list(ignore_list.keys()):
        if ignore_list[name] < now:
            del ignore_list[name]
    time.sleep(5)





===================================================================



I want a function that can accept a JSON structure containing up to 5 , five digit numbers that will return a bytearray composed of those numbers followed by 'NIMI_DEV_5792'  





















def decode_name(adv_data):
    # Convert memoryview to bytes
    adv_bytes = bytes(adv_data)
    i = 0
    while i < len(adv_bytes):
        length = adv_bytes[i]
        if length == 0:
            break
        ad_type = adv_bytes[i + 1]
        if ad_type == _ADV_TYPE_NAME:
            try:
                return adv_bytes[i + 2:i + length + 1].decode('utf-8')
            except UnicodeError:
                return None
        i += length + 1
    return None

def decode_keywords(adv_data):
    adv_bytes = bytes(adv_data)
    i = 0
    while i < len(adv_bytes):
        length = adv_bytes[i]
        if length == 0:
            break
        ad_type = adv_bytes[i + 1]
        # BLE flags have ad_type 0x01 and length 2
        if ad_type == 0x01 and length == 2:
            return adv_bytes[i:i+length+1]  # includes length, type, value
        i += length + 1
    return None